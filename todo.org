* add C4DEFER_SCOPE(name) & C4DEFER_TO(scope)
** check cleanup docs for fn cleanup
** use dyna as cleanup marker
** push defers and pop on exit
** free dyna before exit


* rename err_start()/_next() to try_X()

* add mpool
** mpool_alloc & mpool_free 
** alloc enough for ptr + ls
** keep ls of allocs in pool

*---
* add c4seq_skip(size_t n)
** add skip(n) method
** do nothing but increase idx if NULL
** forward to recs_iter in tbl
** forward skip to src seq_map
* add struct c4seq *_c4seq_gather(...)
** add c4seq_gather macro to NULL terminate
* add struct c4seq *c4seq_spread(self, cnt)
* add ls_seq
** encapsulate next pre-fetch
** replaces DO_LS

* add array_seq
** init with it_size

* add vicsy_peer_save()
* implement c4map_merge()
** add c4map_splice()
* add init macros
** ex C4MAP(var, cmp)
** declare var & run init
** add for all types
* add map to README
* add tbl_reset()
** merge rec
* add vicsy_peer_load()
* add automagic freeing of cols & tbls like err/val types
* add pthread chan based on vec & semaphore (sbcl docs)
* add C4PANIC/RECOVER macros
** use jmpbuf
** register recovers in ctx
*** else print stacktrace from tries & exit
* add C4ERR_ENABLED define
** set to 1 if not defined in err.h
** use to bypass all error macros
* add c4mbox based on pthread semaphore & queue
