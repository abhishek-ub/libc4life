* add struct c4seq
** move tbl_seq/map_seq structs to .c-files
*** add c4seq members
** contains void *next() / void free()
*** call regular iter via STRUCTOF in fns
*** add c4seq_next, c4seq_free trampolines
** add C4SEQ_DO/MAP
* ---
* free recs in c4tbl_free()
* rename rename slab_get to slab_idx
* add c4dyna
** use slab for its
** take it_size as param
** keep internal len
** add dyna_iter with slab_iter field
** use instead of slab in c4map

* add C4DEFER_SCOPE(name) & C4DEFER_TO(scope)
** use dyna as cleanup marker
** push defers and pop on exit
** free dyna before exit
* add c4ls_seq
* add c4slab_seq
* rename err_start()/_next() to try_X()
* add db dir
** move tbl, rec & cols
** investigate recursive cmake globs
* add vicsy_peer_save()
* implement c4map_merge()
** add c4map_splice()
* add init macros
** ex C4MAP(var, cmp)
** declare var & run init
** add for all types
* add map to README
* add tbl_reset()
** merge rec
* add vicsy_peer_load()
* add automagic freeing of cols & tbls like err/val types
* add pthread chan based on vec & semaphore (sbcl docs)
* add C4PANIC/RECOVER macros
** use jmpbuf
** register recovers in ctx
*** else print stacktrace from tries & exit
* add C4ERR_ENABLED define
** set to 1 if not defined in err.h
** use to bypass all error macros
* add struct c4proc
** based on pthreads
** mailbox based on semaphore & queue
* add seqs dir
** move dyna, ls, map, slab & seq
