* change to random deletes in perf test
* add register vars
* check gnu extensions for inlining
** add custom inline macro?
* test benchmark with alt. malloc imp
* simplify seq example to use dyna of ints and inc
* document rolling your own allocator
* ---
* add c4pair with variable key/val size
** one char data[] member, c4pair_x(pair), c4pair_y(pair, x_size) 
* add c4bset with it_size
** base on dyna/bmap
** return ptr from insert/add
** add C4BSET_ADD / INSERT with type params to streamline usage
*** copy deref
* change c4bmap to use cbset
* adapt cbmap to pair with variable key/val size
* add C4SLAB_DO
* add C4BMAP_DO
** loop entries
** use in tbl & rec
* add c4ls_seq
** encapsulate next pre-fetch from LS_DO
* add c4array_seq
** init with void *, len & it_size
* rename err_start()/_next() to try_X()
* add c4seq_skip(size_t n)
** add skip(n) method
** do nothing but increase idx if NULL
** forward to recs_iter in tbl
** forward to src seq_map
** init to call c4seq_next() n times
---
* add automagic freeing of cols & tbls like err/val types
* add vicsy_peer_save()
* add c4pair
* implement c4map_merge()
** add c4map_splice()
* add tbl_reset()
** merge rec
* add vicsy_peer_load()
* add struct c4seq *_c4seq_gather(...)
** add c4seq_gather macro to NULL terminate
* add struct c4seq *c4seq_spread(self, cnt)
* add pthread chan based on vec & semaphore (sbcl docs)
* add C4PANIC/RECOVER macros
** use jmpbuf
** register recovers in ctx
*** else print stacktrace from tries & exit
* add C4ERR_ENABLED define
** set to 1 if not defined in err.h
** use to bypass all error macros
* add c4mbox based on pthread semaphore & queue
